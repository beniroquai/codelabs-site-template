"use strict";(self.webpackChunkuc_2_docs=self.webpackChunkuc_2_docs||[]).push([[2354],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=o,k=m["".concat(s,".").concat(u)]||m[u]||d[u]||i;return n?r.createElement(k,a(a({ref:t},c),{},{components:n})):r.createElement(k,a({ref:t},c))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,a[1]=l;for(var p=2;p<i;p++)a[p]=n[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},89914:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=n(87462),o=(n(67294),n(3905));const i={},a="Documentation for Stepper Motor Controller with Rotational Encoder (TMC2209 + AS5600)",l={unversionedId:"Electronics/StepperMotorBackpack",id:"Electronics/StepperMotorBackpack",title:"Documentation for Stepper Motor Controller with Rotational Encoder (TMC2209 + AS5600)",description:"Overview:",source:"@site/docs/03_Electronics/11-StepperMotorBackpack.md",sourceDirName:"03_Electronics",slug:"/Electronics/StepperMotorBackpack",permalink:"/docs/Electronics/StepperMotorBackpack",draft:!1,tags:[],version:"current",sidebarPosition:11,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"PS4-Controller",permalink:"/docs/Electronics/PS4-Controller"},next:{title:"Python commands",permalink:"/docs/Electronics/uc2e5.2"}},s={},p=[{value:"<strong>Overview:</strong>",id:"overview",level:2},{value:"<strong>Components:</strong>",id:"components",level:2},{value:"<strong>Pin Descriptions:</strong>",id:"pin-descriptions",level:2},{value:"<strong>Power Requirements:</strong>",id:"power-requirements",level:2},{value:"<strong>Features:</strong>",id:"features",level:2},{value:"<strong>Wiring:</strong>",id:"wiring",level:2},{value:"Xiao Pin Connections for Motor Controller with Encoder (TMC2209)",id:"xiao-pin-connections-for-motor-controller-with-encoder-tmc2209",level:2},{value:"<strong>Pinout for Xiao:</strong>",id:"pinout-for-xiao",level:2},{value:"<strong>Connections to Stepper Motor Controller (TMC2209):</strong>",id:"connections-to-stepper-motor-controller-tmc2209",level:2},{value:"Code Example",id:"code-example",level:2},{value:"Required Libraries:",id:"required-libraries",level:2},{value:"Wiring:",id:"wiring-1",level:2},{value:"In Action:",id:"in-action",level:2},{value:"Code:",id:"code",level:2},{value:"Key Components:",id:"key-components",level:2}],c={toc:p};function d(e){let{components:t,...i}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"documentation-for-stepper-motor-controller-with-rotational-encoder-tmc2209--as5600"},"Documentation for Stepper Motor Controller with Rotational Encoder (TMC2209 + AS5600)"),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(41990).Z,width:"3648",height:"2736"})),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(31534).Z,width:"3648",height:"2736"})),(0,o.kt)("h2",{id:"overview"},(0,o.kt)("strong",{parentName:"h2"},"Overview:")),(0,o.kt)("p",null,"This motor controller is designed to control a stepper motor using the TMC2209 driver with optional feedback from a rotational encoder (AS5600). The Xiao microcontroller handles communication and control."),(0,o.kt)("h2",{id:"components"},(0,o.kt)("strong",{parentName:"h2"},"Components:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"TMC2209 Stepper Driver:")," Manages the stepper motor's power and movement. It offers features like StallGuard for homing without limit switches."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"AS5600 Encoder:")," A magnetic encoder that tracks the stepper motor\u2019s rotational position. Connected via I2C, it provides high-precision feedback for motor positioning.")),(0,o.kt)("h2",{id:"pin-descriptions"},(0,o.kt)("strong",{parentName:"h2"},"Pin Descriptions:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"DIR (Direction):")," Controls the rotational direction of the stepper motor (Clockwise/Counter-Clockwise). Controlled via ",(0,o.kt)("strong",{parentName:"li"},"PA02_A0_D0"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"STEP (Step Pulse):")," Sends pulses to the motor for each step. Controlled via ",(0,o.kt)("strong",{parentName:"li"},"PA10_A2_D2"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"UART (TX/RX):")," The Xiao communicates with the TMC2209 driver for advanced functions such as StallGuard and diagnostics via UART on ",(0,o.kt)("strong",{parentName:"li"},"PB08_A6_TX")," and ",(0,o.kt)("strong",{parentName:"li"},"PB09_D7_RX"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"I2C (SDA/SCL):")," Connects the Xiao to the AS5600 encoder for feedback. I2C pins on the Xiao are ",(0,o.kt)("strong",{parentName:"li"},"PA8_A4_D4_SDA")," and ",(0,o.kt)("strong",{parentName:"li"},"PA9_A5_D5_SCL"),".")),(0,o.kt)("h2",{id:"power-requirements"},(0,o.kt)("strong",{parentName:"h2"},"Power Requirements:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"5V Input:")," The Xiao uses its internal buck converter to supply 3.3V to the other components."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"12V Input:")," Powers the motor and is regulated to 5V and 3.3V via a DC-DC converter for the motor driver and encoder.")),(0,o.kt)("h2",{id:"features"},(0,o.kt)("strong",{parentName:"h2"},"Features:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"StallGuard Functionality:")," This feature detects motor stall conditions and is useful for homing operations without mechanical limit switches."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"I2C Encoder (AS5600):")," Provides high-precision feedback on motor position, allowing for closed-loop control in certain applications.")),(0,o.kt)("h2",{id:"wiring"},(0,o.kt)("strong",{parentName:"h2"},"Wiring:")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Motor Wiring:")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Connect the motor windings to the respective outputs on the TMC2209."),(0,o.kt)("li",{parentName:"ul"},"Windings A (A+, A-) and B (B+, B-) are connected to ",(0,o.kt)("strong",{parentName:"li"},"OA1"),", ",(0,o.kt)("strong",{parentName:"li"},"OA2"),", ",(0,o.kt)("strong",{parentName:"li"},"OB1"),", ",(0,o.kt)("strong",{parentName:"li"},"OB2")," pins."))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Encoder Wiring:")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"SDA")," (I2C Data) to ",(0,o.kt)("strong",{parentName:"li"},"PA8_A4_D4_SDA")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"SCL")," (I2C Clock) to ",(0,o.kt)("strong",{parentName:"li"},"PA9_A5_D5_SCL")))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Power:")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"12V Input to ",(0,o.kt)("strong",{parentName:"li"},"12V Pin")," (via JST)."),(0,o.kt)("li",{parentName:"ul"},"GND to common ground.")))),(0,o.kt)("h2",{id:"xiao-pin-connections-for-motor-controller-with-encoder-tmc2209"},"Xiao Pin Connections for Motor Controller with Encoder (TMC2209)"),(0,o.kt)("p",null,"Based on the schematic provided for the stepper motor controller (TMC2209) with Xiao, here are the pin connections between the Xiao board and different elements such as the motor controller and encoder:"),(0,o.kt)("h2",{id:"pinout-for-xiao"},(0,o.kt)("strong",{parentName:"h2"},"Pinout for Xiao:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"PA02_A0_D0")," (Pin 1): ",(0,o.kt)("strong",{parentName:"li"},"DIR")," (Direction for motor control)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"PA4_A1_D1")," (Pin 2): ",(0,o.kt)("strong",{parentName:"li"},"MOT_DIR")," (Motor direction)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"PA10_A2_D2")," (Pin 3): ",(0,o.kt)("strong",{parentName:"li"},"STEP")," (Stepper motor step control)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"PA11_A3_D3")," (Pin 4): ",(0,o.kt)("strong",{parentName:"li"},"MOT_STEP")," (Step control for motor)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"PA8_A4_D4_SDA")," (Pin 5): ",(0,o.kt)("strong",{parentName:"li"},"I2C SDA")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"PA9_A5_D5_SCL")," (Pin 6): ",(0,o.kt)("strong",{parentName:"li"},"I2C SCL")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"PB08_A6_TX")," (Pin 7): ",(0,o.kt)("strong",{parentName:"li"},"TX UART")," (for TMC2209 UART communication)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"PB09_D7_RX")," (Pin 8): ",(0,o.kt)("strong",{parentName:"li"},"RX UART")," (for TMC2209 UART communication)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"PA7_A8_D8_SCK")," (Pin 9): ",(0,o.kt)("strong",{parentName:"li"},"I2C SCL (Alternative)"))),(0,o.kt)("h2",{id:"connections-to-stepper-motor-controller-tmc2209"},(0,o.kt)("strong",{parentName:"h2"},"Connections to Stepper Motor Controller (TMC2209):")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"DIR"),": Controls the direction of the stepper motor."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"STEP"),": Steps the motor in the specified direction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"UART_PICO"),": UART communication to the TMC2209 (TX from Xiao)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"UART_POCI"),": UART communication from the TMC2209 (RX to Xiao)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"I2C SDA / SCL"),": Communication with an external encoder (such as the AS5600 rotational encoder).")),(0,o.kt)("h2",{id:"code-example"},"Code Example"),(0,o.kt)("p",null,"Here\u2019s a basic ESP32S3 code to control the TMC2209 stepper motor driver and AS5600 encoder (since AS5300 is typically a typo for AS5600, which is more common) in a feedback loop for 360\xb0 rotation in both directions. The code sets up the motor driver and encoder, reads the encoder's position, and runs the motor for a full revolution in either direction based on feedback from the encoder."),(0,o.kt)("h2",{id:"required-libraries"},"Required Libraries:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"TMCStepper")," for communicating with the TMC2209 driver."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Wire")," for I2C communication with the AS5600 encoder.")),(0,o.kt)("h2",{id:"wiring-1"},"Wiring:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"EN")," -> D10"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"DIR")," (Direction) -> D8"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"STEP")," (Step Pulse) -> D9"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"I2C SDA")," -> PA8_A4_D4_SDA (Pin 5)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"I2C SCL")," -> PA9_A5_D5_SCL (Pin 6)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"UART TX")," -> PB08_A6_TX (Pin 7)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"UART RX")," -> PB09_D7_RX (Pin 8)")),(0,o.kt)("h2",{id:"in-action"},"In Action:"),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(93538).Z,width:"800",height:"450"})),(0,o.kt)("h2",{id:"code"},"Code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <TMCStepper.h>\n#include <Wire.h>\n#include <FastAccelStepper.h>  // Include the FastAccelStepper library\n\n// TMC2209 Settings\n#define STALL_VALUE     100  // StallGuard sensitivity [0..255]\n#define EN_PIN           D10   // PA4_A1_D1 (Pin 2) Enable pin for motor driver\n#define DIR_PIN          D8   // PA02_A0_D0 (Pin 1) Direction pin\n#define STEP_PIN         D9   // PA10_A2_D2 (Pin 3) Step pin\n#define SW_RX            D7   // PB09_D7_RX (Pin 8) UART RX pin for TMC2209\n#define SW_TX            A6   // PB08_A6_TX (Pin 7) UART TX pin for TMC2209\n#define SERIAL_PORT Serial1  // UART Serial port for TMC2209\n#define DRIVER_ADDRESS 0b00  // TMC2209 driver address\n#define R_SENSE 0.11f        // Current sense resistor for TMC2209\n#define MOT_DIAG        D3\n\n// UC2-ESP I2C Settings\n#define SDA_PIN_UC2 D2\n#define SCL_PIN_UC2 D1\n// AS5311 I2C Settings\n#define SDA_PIN D4          // PA8_A4_D4_SDA (Pin 5) I2C SDA\n#define SCL_PIN D5           // PA9_A5_D5_SCL (Pin 6) I2C SCL\n#define AS5311_ADDR 0x36     // I2C address for AS5311\n\n// Encoder settings\n#define MAX_ENCODER_VALUE 16384  // AS5311 is a 14-bit encoder (2^14 = 16384 steps per revolution)\n\n// FastAccelStepper setup\nFastAccelStepperEngine engine = FastAccelStepperEngine();  // FastAccelStepper engine instance\nFastAccelStepper *stepper = NULL;  // FastAccelStepper instance\n\n// TMC2209 instance\nTMC2209Stepper driver(&SERIAL_PORT, R_SENSE, DRIVER_ADDRESS);\n\n// Function to read AS5311 encoder value over I2C\nint readEncoder() {\n  Wire.beginTransmission(AS5311_ADDR);\n  Wire.write(0x0C);  // Register for reading high byte of encoder position\n  Wire.endTransmission();\n  Wire.requestFrom(AS5311_ADDR, 2);\n  int high_byte = Wire.read();\n  int low_byte = Wire.read();\n  int position = (high_byte << 8) | low_byte;\n  return position;\n}\n\nvoid setup() {\n  Serial.begin(115200);         // Init serial port and set baudrate\n  while(!Serial);               // Wait for serial port to connect\n  Serial.println("\\nStart...");\n\n  // Start Serial communication for TMC2209\n  SERIAL_PORT.begin(115200);\n\n  // Pin setup for motor control\n  pinMode(EN_PIN, OUTPUT);\n  digitalWrite(EN_PIN, LOW); // Enable motor driver (LOW to enable)\n\n  // Setup TMC2209 driver\n  driver.begin();               // Initiate TMC2209\n  driver.toff(4);               // Enable driver with off time\n  driver.blank_time(24);         // Set blank time\n  driver.rms_current(400);       // Set motor current to 400mA\n  driver.microsteps(16);         // Set microstepping to 16\n  driver.TCOOLTHRS(0xFFFFF);     // Set threshold for switching to StealthChop\n  driver.semin(5);               // Enable StallGuard with minimum threshold\n  driver.semax(2);               // Set maximum StallGuard threshold\n  driver.sedn(0b01);             // Set StallGuard deceleration\n  driver.SGTHRS(STALL_VALUE);    // Set StallGuard sensitivity\n\n  // Setup I2C for AS5311 encoder\n  Wire.begin(SDA_PIN, SCL_PIN);  // Initialize I2C with specified pins\n\n  // FastAccelStepper setup\n  engine.init();  // Initialize the FastAccelStepper engine\n  stepper = engine.stepperConnectToPin(STEP_PIN);  // Connect stepper to the STEP_PIN\n  if (stepper) {\n    stepper->setDirectionPin(DIR_PIN);  // Set the direction pin\n    stepper->setEnablePin(EN_PIN);      // Set the enable pin\n    stepper->enableOutputs();           // Enable motor outputs\n    stepper->setAutoEnable(true);       // Automatically enable motor when moving\n    stepper->setSpeedInHz(10000);        // Set initial speed (steps per second)\n    stepper->setAcceleration(10000);      // Set acceleration in steps/second^2\n  }\n}\n\nvoid loop() {\n  static uint32_t last_time = 0;\n  uint32_t ms = millis();\n\n  // Read encoder position and use it in feedback loop\n  int encoderValue = readEncoder();\n\n  // Control motor movement based on encoder feedback\n  /*\n  if (encoderValue < MAX_ENCODER_VALUE / 2) {\n    stepper->moveTo(1000);  // Move forward by 1000 steps\n  } else if (encoderValue >= MAX_ENCODER_VALUE / 2 && encoderValue < MAX_ENCODER_VALUE) {\n    stepper->moveTo(-1000); // Move backward by 1000 steps\n  }*/\n\n  // Adjust speed via serial input\n  while(Serial.available() > 0) {\n    int8_t read_byte = Serial.read();\n    if (read_byte == \'0\') {\n      Serial.println("Stop");\n      stepper->forceStop();  // Stop the motor\n    }\n    else if (read_byte == \'1\') {\n      Serial.println("Start");\n      stepper->move(10000);    // Move forward by 1000 steps\n    }\n    /*\n    else if (read_byte == \'+\') {\n      stepper->setSpeedInHz(stepper->getSpeedInHz() + 100); // Speed up motor\n    }\n    else if (read_byte == \'-\') {\n      stepper->setSpeedInHz(stepper->getSpeedInHz() - 100); // Slow down motor\n    }*/\n  }\n\n  // Print StallGuard results and motor current every 100ms\n  if ((ms - last_time) > 100) {\n    last_time = ms;\n    Serial.print("SG Result: ");\n    Serial.print(driver.SG_RESULT(), DEC);  // Print StallGuard value\n    Serial.print(" Current: ");\n    Serial.println(driver.cs2rms(driver.cs_actual()), DEC);  // Print motor current\n    Serial.print("Encoder Value: ");\n    Serial.println(encoderValue);\n\n  }\n}\n')),(0,o.kt)("h2",{id:"key-components"},"Key Components:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Setup TMC2209"),": The motor driver is initialized using UART communication and the current limit is set. StealthChop mode is enabled for quieter operation."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Encoder Setup (AS5600)"),": Uses I2C to read the encoder\u2019s current position. The encoder provides feedback with a 12-bit resolution (4096 steps per revolution)."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"MoveStepper Function"),": Moves the motor in a given direction (based on step count). The direction and steps are controlled using the DIR and STEP pins."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Feedback Loop"),": The motor moves based on encoder feedback. If the encoder position is less than 180\xb0 (half of 4096 steps), the motor moves forward; otherwise, it moves backward to maintain a 360\xb0 operation.")))}d.isMDXComponent=!0},41990:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/IMG_20241010_151621-0548a85dcfd205e19240f75c7d1c98ab.jpg"},31534:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/IMG_20241010_175137-5fb9704943c604c54d168a4cfa81d44f.jpg"},93538:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/VID_20241011_142459-b7ffa81e89378e6ecb628535343883bd.gif"}}]);